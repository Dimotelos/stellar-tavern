plugins {
    id 'idea'
    id 'java-library'
    id 'maven-publish'
    id 'net.neoforged.moddev.legacyforge' version '2.0.76'
}

tasks.named('wrapper', Wrapper).configure {
    // 在这里定义 wrapper 的值，以避免在更新 gradlew.properties 时总是需要这样做。
    // 将此切换为 Wrapper.DistributionType.ALL 将下载完整的 Gradle 源代码，其中包含附带的文档，
    // 可以在光标悬停在 Gradle 类和方法上时查看。然而，这会增加 Gradle 的文件大小。
    // 如果你将其切换为 ALL，请随后运行 Gradle wrapper 任务两次。
    // （通过检查 gradle/wrapper/gradle-wrapper.properties 来验证 distributionUrl 是否现在指向 `-all`）
    distributionType = Wrapper.DistributionType.BIN
}

version = mod_version
group = mod_group_id

repositories {
    mavenLocal()
}

base {
    archivesName = mod_id
}

// Mojang 在 1.20.1 中向最终用户提供 Java 21，因此 mod 应目标为 Java 17。
java.toolchain.languageVersion = JavaLanguageVersion.of(17)

legacyForge {
    // 指定要使用的 MinecraftForge 版本。
    version = project.minecraft_version + '-' + project.forge_version

    parchment {
        mappingsVersion = project.parchment_mappings_version
        minecraftVersion = project.parchment_minecraft_version
    }

    // 这一行是可选的。访问转换器会自动检测。
    // accessTransformers = project.files('src/main/resources/META-INF/accesstransformer.cfg')

    // 默认的运行配置。
    // 这些可以根据需要进行调整、删除或复制。
    runs {
        client {
            client()

            // 要加载游戏测试的命名空间列表，以逗号分隔。空值表示所有命名空间。
            systemProperty 'forge.enabledGameTestNamespaces', project.mod_id
        }

        server {
            server()
            programArgument '--nogui'
            systemProperty 'forge.enabledGameTestNamespaces', project.mod_id
        }

        // 此运行配置启动 GameTestServer 并运行所有注册的游戏测试，然后退出。
        // 默认情况下，如果没有提供游戏测试，服务器将崩溃。
        // 游戏测试系统也默认在其他运行配置中通过 /test 命令启用。
        gameTestServer {
            type = "gameTestServer"
            systemProperty 'forge.enabledGameTestNamespaces', project.mod_id
        }

        data {
            data()

            // 示例：覆盖上面 configureEach 中设置的工作目录，如果需要使用请取消注释。
            // gameDirectory = project.file('run-data')

            // 指定数据生成的 modid，输出生成的资源的位置，以及查找现有资源的位置。
            programArguments.addAll '--mod', project.mod_id, '--all', '--output', file('src/generated/resources/').getAbsolutePath(), '--existing', file('src/main/resources/').getAbsolutePath()
        }

        // 适用于上述所有运行配置
        configureEach {
            // 推荐在用户开发环境中使用的日志数据
            // 可以根据需要添加/删除标记，以逗号分隔。
            // "SCAN": 用于 mod 扫描。
            // "REGISTRIES": 用于触发注册表事件。
            // "REGISTRYDUMP": 用于获取所有注册表的内容。
            systemProperty 'forge.logging.markers', 'REGISTRIES'

            // 推荐的控制台日志级别
            // 你可以在这里设置各种级别。
            // 请阅读：https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels
            logLevel = org.slf4j.event.Level.DEBUG
        }
    }

    mods {
        // 定义 mod 与源代码的绑定
        // 这些用于告诉游戏哪些源代码属于哪个 mod
        // 在单个 mod 项目中大多是可选的
        // 但多 mod 项目应为每个 mod 定义一个
        "${mod_id}" {
            sourceSet(sourceSets.main)
        }
    }
}

// 包含由数据生成器生成的资源。
sourceSets.main.resources { srcDir 'src/generated/resources' }

// 设置一个名为 'localRuntime' 的依赖配置，以及一个名为 'modLocalRuntime' 的反混淆配置
// 这些配置应代替 'runtimeOnly' 使用，以声明
// 一个在运行时测试中存在的依赖项，但它是“可选的”，
// 意味着依赖此 mod 的项目不会拉取它。
configurations {
    runtimeClasspath.extendsFrom localRuntime
}
obfuscation {
    createRemappingConfiguration(configurations.localRuntime)
}

dependencies {
    // 如果你希望声明对 mod 的依赖，请确保使用 'mod*' 配置，以便它们被重新映射。
    // 有关更多信息，请参阅：https://github.com/neoforged/ModDevGradle/blob/main/LEGACY.md#remapping-mod-dependencies

    // 示例：使用 JEI 的可选 mod 依赖
    // JEI API 在编译时声明，而完整的 JEI 工件在运行时使用
    // modCompileOnly "mezz.jei:jei-${mc_version}-common-api:${jei_version}"
    // modCompileOnly "mezz.jei:jei-${mc_version}-neoforge-api:${jei_version}"
    // 我们将完整版本添加到 localRuntime，而不是 runtimeOnly，以便我们不发布对其的依赖
    // modLocalRuntime "mezz.jei:jei-${mc_version}-neoforge:${jei_version}"

    // 示例：使用 ./libs 中的 mod jar 的 mod 依赖，使用 flat dir 仓库
    // 这映射到 ./libs/coolmod-${mc_version}-${coolmod_version}.jar
    // 组 ID 在搜索时被忽略 —— 在这种情况下，它是 "blank"
    // modImplementation "blank:coolmod-${mc_version}:${coolmod_version}"

    // 示例：使用文件作为依赖的 mod 依赖
    // modImplementation files("libs/coolmod-${mc_version}-${coolmod_version}.jar")

    // 示例：使用姐妹或子项目的项目依赖
    // modImplementation project(":myproject")

    // 更多信息：
    // http://www.gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html
    // http://www.gradle.org/docs/current/userguide/dependency_management.html
}

// 如果你希望配置 Mixin，请取消注释以下行。Mixin 文件应命名为 modid.mixins.json。
/*
mixin {
    add sourceSets.main, "${mod_id}.refmap.json"
    config "${mod_id}.mixins.json"
}

dependencies {
    annotationProcessor 'org.spongepowered:mixin:0.8.5:processor'
}

jar {
    manifest.attributes([
            "MixinConfigs": "${mod_id}.mixins.json"
    ])
}
*/

// 此代码块扩展了指定资源目标中所有声明的替换属性。
// 缺少属性将导致错误。属性使用 ${} Groovy 表示法进行扩展。
var generateModMetadata = tasks.register("generateModMetadata", ProcessResources) {
    var replaceProperties = [
            minecraft_version        : minecraft_version,
            minecraft_version_range  : minecraft_version_range,
            forge_version            : forge_version,
            forge_version_range      : forge_version_range,
            loader_version_range     : loader_version_range,
            mod_id                   : mod_id,
            mod_name                 : mod_name,
            mod_license              : mod_license,
            mod_version              : mod_version,
            mod_authors              : mod_authors,
            mod_description          : mod_description
    ]
    inputs.properties replaceProperties
    expand replaceProperties
    from "src/main/templates"
    into "build/generated/sources/modMetadata"
}
// 将 "generateModMetadata" 的输出作为构建的输入目录
// 这适用于通过 Gradle 和 IDE 进行构建。
sourceSets.main.resources.srcDir generateModMetadata
// 为了避免手动运行 "generateModMetadata"，使其在每次项目重新加载时运行
legacyForge.ideSyncTask generateModMetadata

// 示例配置以允许使用 maven-publish 插件进行发布
publishing {
    publications {
        register('mavenJava', MavenPublication) {
            from components.java
        }
    }
    repositories {
        maven {
            url "file://${project.projectDir}/repo"
        }
    }
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8' // 使用 UTF-8 字符集进行 Java 编译
}

// IDEA 不再自动下载依赖项的源代码/javadoc jar，因此我们需要显式启用此行为。
idea {
    module {
        downloadSources = true
        downloadJavadoc = true
    }
}